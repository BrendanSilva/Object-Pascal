program htmlmos;

{$APPTYPE CONSOLE}

{
------------------------------------------------------------------------------

                                 HTMLMOS v1.6
                                 ============
                    A basic tool to create mosaics in HTML
                     Written by Brendan Silva - 2021~2022

                       https://github.com/BrendanSilva

                   https://archive.org/details/@brendansilva

              https://youtube.com/channel/UCYi8iNEIRKAh76Gjb62nDDA

This  program is free software: you can redistribute it and/or modify it under
the  terms of the GNU General Public License as published by the Free Software
Foundation,  either  version  3 of the License. This program is distributed in
the  hope  that  it will be useful, but without any warranty; without even the
implied  warranty  of merchantability or fitness for a particular purpose. See
the GNU General Public License for more details.

                                   English:
                                   ========

     This software uses colored block characters to create mosaics on HTML
       pages. Source code is included. I recommend using small pictures.

All  my  software  is free (and open source) and always will be. Thank you for
using  this  software.  This encourages me to improve it more and more. If you
would  like  to consider a little donation as an incentive, you can donate via

             Bitcoin: bc1qyctqutnah9v90hwufk9eqaxvze7k5rtvrtvpr7

                         Pix: brendan.edicao@gmail.com

                  I appreciate your help. Thanks in advance.


                                 Português-BR:
                                 =============

      Usando caracteres de blocos coloridos, esse programa (contém o
           código-fonte) cria pequenos mosaicos em páginas HTML.
                         Utilize imagens pequenas.

     Se você é brasileiro e gostaria de apoiar o meu trabalho, pode fazer,
         se quiser, uma pequena doação de qualquer valor através do:

             Bitcoin: bc1qyctqutnah9v90hwufk9eqaxvze7k5rtvrtvpr7

                         Pix: brendan.edicao@gmail.com

                               Muito obrigado.

------------------------------------------------------------------------------
}

uses
  Classes, Graphics, Math, SysUtils, StrUtils, Windows;

const
  PgVersion : ShortString = '1.6';
  HexString : ShortString = '0123456789ABCDEF';
  ISampling : Array [0..9] of Word = (0, $10, $101, $111, $AA, $155, $EE, $FE, $1EF, $1FF);
  SpanStyle : Array [0..1] of ShortString = ('background-color:#', 'color:#');
  StlPixSng : Array [0..1] of ShortString = ('#"+p[x]+"', 'rgb("+x+","+x+","+x+")');
  StlPixDbl : Array [0..1] of ShortString = ('background-color:#"+p[x]+";color:#"+p[y]+"', 'background-color:rgb("+x+","+x+","+x+");color:rgb("+y+","+y+","+y+")');

var
  BmpInput            : Graphics.TBitmap;
  BmpScale            : Integer;
  C, Method, N, Q     : Byte;
  Closing             : Boolean;
  H, I, W, X          : Word;
  HtmBuffer, Palette  : String;
  HtmSeek, PalSeek    : Integer;
  ShortBuffer         : ShortString;
  Floating            : Single;
  StdinBitmap         : TMemoryStream;

  PseudoJS            : Array of Cardinal;
  PseudoPal           : Array of Word;

  BmpPixels           : Array [0..1] of PByteArray;
  DefCol              : Array [0..1] of Cardinal;
  HTagColor           : Array [0..1] of ShortString;
  JTagColor           : Array [0..1] of Word;
  Px                  : Array [0..2] of Byte;
  Rx                  : Array [0..3] of Integer;
  Tag                 : Array [0..1] of Byte;

{------------------------------------------------------------------------------}

function  Inv(Value : Cardinal): Cardinal; begin Result := ((Value and 255) shl 16) or (Value and 65280) or ((Value shr 16) and 255); end;
function  SetStretchBltMode(DC: LongWord; StretchMode: Integer): Integer; stdcall; external 'gdi32.dll';
procedure Merge(SAppend : String; var SSource : String; var SSeek : Integer; SLength : Integer); var L : Integer; begin for L := 1 to SLength do SSource[SSeek + L] := SAppend[L]; SSeek := SSeek + SLength; end;

{------------------------------------------------------------------------------}

function GetBitmapFromStdin : Boolean;
var
  StdinHandle : THandleStream;
  StdinRead   : Word;
  StdinBuffer : Array [0..65534] of Byte;
begin
  StdinBitmap := TMemoryStream.Create;
  StdinHandle := THandleStream.Create(GetStdHandle(STD_INPUT_HANDLE));
  StdinHandle.Seek(0, 0);
  try
    repeat
      StdinRead := StdinHandle.Read(StdinBuffer, 65535);
      if StdinRead > 0 then StdinBitmap.Write(StdinBuffer, StdinRead);
    until StdinRead = 0;
    StdinBitmap.Position := 0;
    Result := True;
  except
    StdinBitmap.Free;
    Result := False;
  end;
  StdinHandle.Free;
end;

{------------------------------------------------------------------------------}

procedure JSCodify;
var
  DI, DS, DC : Cardinal;
begin
  DC := 0;
  DefCol[1] := 1 shl 28;
  for DI := 0 to Length(PseudoJS) - 1 do
  begin
    DefCol[0] := DefCol[1];
    DefCol[1] := PseudoJS[DI];
    if DefCol[0] = DefCol[1] then Inc(DC) else
    begin
      ShortBuffer := '';
      case DefCol[0] shr 24 of
        0: if DC < 5 then for DS := 0 to DC do ShortBuffer := ShortBuffer + 'w();' else ShortBuffer := 'for(r=0;r<' + IntToStr(DC + 1) + ';r++)w();';
        1: if DC < 4 then for DS := 0 to DC do ShortBuffer := ShortBuffer + 'f(' + IntToStr(DefCol[0] and 4095) + ');' else ShortBuffer := 'for(r=0;r<' + IntToStr(DC + 1) + ';r++)f(' + IntToStr(DefCol[0] and 4095) + ');';
        2: if DC < 4 then for DS := 0 to DC do ShortBuffer := ShortBuffer + 'b(' + IntToStr((DefCol[0] shr 12) and 4095) + ');' else ShortBuffer := 'for(r=0;r<' + IntToStr(DC + 1) + ';r++)b(' + IntToStr((DefCol[0] shr 12) and 4095) + ');';
        3: if DC < 3 then for DS := 0 to DC do ShortBuffer := ShortBuffer + 'd(' + IntToStr((DefCol[0] shr 12) and 4095) + ',' + IntToStr(DefCol[0] and 4095) + ');' else ShortBuffer := 'for(r=0;r<' + IntToStr(DC + 1) + ';r++)d(' + IntToStr((DefCol[0] shr 12) and 4095) + ',' + IntToStr(DefCol[0] and 4095) + ');';
        4: ShortBuffer := 'l();';
      end;
      DC := 0;
      Merge(ShortBuffer, HtmBuffer, HtmSeek, Length(ShortBuffer));
    end;
  end;
end;

{------------------------------------------------------------------------------}

begin

  if ParamStr(1) = '' then
  begin
    WriteLn(
        #10 + 'HTMLMOS v' + PgVersion + ' - Freeware and Open Source'
      + #10 + '====================================' + StringOfChar('=',Length(PgVersion))
      + #10
      + #10 + '  A basic tool to create mosaics in HTML.'
      + #10 + '  Brendan Silva - youtube.com/channel/UCYi8iNEIRKAh76Gjb62nDDA'
      + #10
      + #10 + '  The source code is available at:'
      + #10 + '    https://github.com/BrendanSilva'
      + #10 + '    https://archive.org/details/@brendansilva'
      + #10
      + #10 + '  Syntax:'
      + #10 + '    HTMLMOS "File.BMP|*" [[Quality]|-js] [Scale] [Page Color] [Canvas Color]'
      + #10 + '                (1)            (2)         (3)       (4)           (5) '
      + #10
      + #10 + '  Parameters:'
      + #10 + '    1. Use "*" in place of the filename to retrieve the bitmap data'
      + #10 + '       from the standard input stream (stdin). HTMLMOS will always'
      + #10 + '       write generated code to the standard output (stdout).'
      + #10 + '       Use output redirectors (">", ">>") to send code into a file.'
      + #10
      + #10 + '       Use "?" to request the image data directly from the clipboard.'
      + #10 + '       Note that the clipboard can store formats not expected by HTMLMOS.'
      + #10 + '       Please always check the exit code (%errorlevel%).'
      + #10
      + #10 + '    2. Quality is a number between 1 and 8. This number is inversely'
      + #10 + '       proportional to the final size of the html file.'
      + #10
      + #10 + '       The "-js" parameter will embed JavaScript. This method creates a'
      + #10 + '       pseudo-palette to generate smaller output code (which is compatible'
      + #10 + '       with any browser). The "-old" parameter works the same, but will'
      + #10 + '       force the conversion to use the basic dithering method as in previous'
      + #10 + '       versions (from 1.0 to 1.4). "-new" will force an experimental method.'
      + #10
      + #10 + '       The "-lum" parameter reduces the size of the code while preserving'
      + #10 + '       smooth gradations in contiguous areas, but will cause the image to'
      + #10 + '       lose saturation.'
      + #10
      + #10 + '    3. The scale factor must be a percentage number (followed by or preceded'
      + #10 + '       by "%") or the area size in square pixels. For example: the value'
      + #10 + '       10000 will ensure that the generated mosaic does not contain more'
      + #10 + '       than 10000 tiles (5000 characters), maintaining the aspect ratio.'
      + #10
      + #10 + '  4-5. Color values can be: zero (0); a positive integer; a hexadecimal'
      + #10 + '       number preceded by "$" or "#". An entry preceded by "#" meets'
      + #10 + '       hexadecimal HTML notation. The precedence of "$" means that the'
      + #10 + '       hexadecimal input is an unsigned 3-byte integer value (commonly used'
      + #10 + '       by graphic editors). Please do not use colors with alpha values.'
      + #10
      + #10 + '       Canvas and page colors are optional. When the default value for the'
      + #10 + '       canvas color is set, redundant assignments of the same color to the'
      + #10 + '       span element will be ignored. You can use this to make the output'
      + #10 + '       code a bit smaller.'
      + #10
      + #10 + '  Usage:'
      + #10 + '    HTMLMOS.EXE pizza.bmp 2 10% #FEEDED > hungry.htm'
      + #10 + '    HTMLMOS.EXE coffee.bmp -js 25% $DECAF > break.html'
      + #10 + '    HTMLMOS.EXE picture.bmp -lum > grayscale.html'
      + #10 + '    HTMLMOS.EXE * -js 40000 < input.bmp > output.html'
      + #10 + '    type input.bmp | HTMLMOS.EXE * . . . . "Page Title" > output.htm'
      + #10
      + #10 + '  Thank you:'
      + #10 + '    All my software is free (and open source) and always will be. Thank'
      + #10 + '    you for using this software. This encourages me to improve it more'
      + #10 + '    and more. If you would like to consider a little donation as an'
      + #10 + '    incentive, you can use the PIX: brendan.edicao@gmail.com'
      + #10 + '    I appreciate your help. Thanks in advance.'
      + #10
      );
    Halt(1);
  end
  else
  begin
    BmpInput := Graphics.TBitmap.Create;
    try
      if FileExists(ParamStr(1)) then Method := 3 else Method := AnsiIndexStr(ParamStr(1),['*','?']) + 1;
      case Method of
      1: if GetBitmapFromStdin then begin BmpInput.LoadFromStream(StdinBitmap); StdinBitmap.Free; end else Abort;
      2: if OpenClipboard(0)   then begin BmpInput.LoadFromClipboardFormat(CF_BITMAP, GetClipboardData(CF_BITMAP), GetClipboardData(CF_PALETTE)); CloseClipboard; end else Abort;
      3: BmpInput.LoadFromFile(ParamStr(1));
      else
        Abort;
      end;
    except
      BmpInput.Free;
      Halt(2);
    end;
  end;

{------------------------------------------------------------------------------}

  Method    := AnsiIndexStr(Lowercase(ParamStr(2)),['-js','-old','-new','-lum']) + 1;
  Closing   := True;
  DefCol[0] := $FFFFFF;
  DefCol[1] := $FFFFFF;
  C := Min(Max(StrToIntDef(ParamStr(2),1), 1), 8) - 1;
  Q := (255 shr C) shl C;
  X := 0;
  for C := 0 to 3 do Rx[C] := -1;
  for C := 0 to 1 do if ParamStr(4 + C) <> '' then if ParamStr(4 + C)[1] = '#' then DefCol[C] := Inv(StrToIntDef('$' + Copy(ParamStr(4 + C), 2, 10), 0)) else DefCol[C] := StrToIntDef(ParamStr(4 + C), 0);
  BmpInput.PixelFormat := pf24bit; // <-- This variable has already been initialized.
  BmpInput.Canvas.Brush.Color := DefCol[1];

{------------------------------------------------------------------------------}

  SetStretchBltMode(BmpInput.Canvas.Handle, 4);
  BmpScale := Min(BmpInput.Width * BmpInput.Height, StrToIntDef(StringReplace(ParamStr(3), '%', '', [rfReplaceAll]), 0));
  if BmpScale < 1 then Floating := 1 else if Pos('%', ParamStr(3)) > 0 then Floating := 0.01 * Min(100, BmpScale) else Floating := 1 / Sqrt((BmpInput.Width * BmpInput.Height) / BmpScale);
  if Floating < 1 then
  begin
    W := Max(1, Trunc(BmpInput.Width  * Floating));
    H := Max(2, Trunc(BmpInput.Height * Floating));
    BmpInput.Canvas.CopyRect(Rect(0, 0, W, H), BmpInput.Canvas, BmpInput.Canvas.ClipRect);
    BmpInput.Width  := W;
    BmpInput.Height := H;
  end;

{------------------------------------------------------------------------------}

  HtmBuffer := '';
  HtmSeek   := 0;
  BmpInput.Height := BmpInput.Height + BmpInput.Height and 1;
  if Method > 0 then
  begin
    if Method < 4 then
    begin
      Palette := '';
      PalSeek := 0;
      SetLength(Palette,   $9000);
      SetLength(PseudoPal, $1000);
      Merge('var p = [', Palette, PalSeek, 9); // <-- I.E. don't support 'const'.
    end;
    SetLength(PseudoJS, (BmpInput.Width + 1) * (BmpInput.Height div 2) + 2);
    SetLength(HtmBuffer, BmpInput.Width * BmpInput.Height * 19 + BmpInput.Height * 4);
  end
  else SetLength(HtmBuffer, BmpInput.Width * BmpInput.Height * 68 + BmpInput.Height * 4);

{------------------------------------------------------------------------------}

  Write(
            '<!DOCTYPE html>'
    + #10 + '<html>'
    + #10 + '<head>'
    + #10 + '<meta name="author" content="Generated with HTMLMOS v' + PgVersion + ' - archive.org/details/htmlmos12">'
    + #10 + '<title>' + StringReplace(StringReplace(ExtractFileName(ParamStr(1)), '*', '', []), '?', '', []) + ParamStr(6) + '</title>'
    + #10 + '</head>'
    + #10 + '<body style="background-color:#' + IntToHex(Inv(DefCol[0]),6) + '">'
    + #10 + '<div style="background-color:#'  + IntToHex(Inv(DefCol[1]),6) + ';color:#' + IntToHex(Inv(DefCol[1]),6) + ';float:left;display:inline-block;font-family:Courier;font-size:8px;">' // line-height:1.2;
  );
  if Method = 0 then Write('<span>');
  WriteLn;

{------------------------------------------------------------------------------}

  for H := 0 to BmpInput.Height div 2 - 1 do
  begin
    BmpPixels[0] := BmpInput.ScanLine[H * 2];
    BmpPixels[1] := BmpInput.ScanLine[H * 2 + 1];
    for W := 0 to BmpInput.Width - 1 do
    begin
      for N := 0 to 1 do
      begin
        if Method = 0 then
        begin
          HTagColor[N] := '';
          for C := 0 to 2 do BmpPixels[N][W * 3 + C] := BmpPixels[N][W * 3 + C] and Q;
        end;
        Rx[N shl 1] := Rx[N shl 1 + 1];
        Rx[N shl 1 + 1] := ((BmpPixels[N][W * 3] shl 16) or (BmpPixels[N][W * 3 + 1] shl 8) or BmpPixels[N][W * 3 + 2]);
        if Rx[N shl 1 + 1] = DefCol[1] then Tag[N] := 0 else // <-- Comparing signed and unsigned types here is purposeful.
        begin
          Tag[N] := 1;
          if Method > 0 then
          begin
            if Method < 4 then
            begin
              for C := 0 to 2 do
              begin
                Floating := BmpPixels[N][W * 3 + C]/17;
                case Method of
                  1: Px[C] := Trunc(Floating) + (1038720 shr (Trunc(Frac(Floating) * 5) shl 2 + N shl 1 + W mod 2)) and 1;
                  2: Px[C] := Trunc(Floating) + Round(Frac(Floating)) and ((W + N) and 1);
                  3: Px[C] := Trunc(Floating) + (ISampling[Trunc(Frac(Floating) * 10)] shr (((H shl 1 + N) mod 3) * 3 + W mod 3)) and 1;
                end;
              end;
              I := (Px[0] shl 8) or (Px[1] shl 4) or Px[2];
              if PseudoPal[I] = 0 then
              begin
                Inc(X);
                PseudoPal[I] := X;
                ShortBuffer := '"';
                for C := 2 downto 0 do ShortBuffer := ShortBuffer + HexString[(Px[C] * 17) shr 4 + 1] + HexString[(Px[C] * 17) and 15 + 1];
                ShortBuffer := ShortBuffer + '",';
                Merge(ShortBuffer, Palette, PalSeek, 9);
              end;
              JTagColor[N] := PseudoPal[I] - 1;
            end
            else
            begin
              X := (BmpPixels[N][W * 3] + BmpPixels[N][W * 3 + 1] + BmpPixels[N][W * 3 + 2]) div 3;
              JTagColor[N] := (MaxIntValue([BmpPixels[N][W * 3], BmpPixels[N][W * 3 + 1], BmpPixels[N][W * 3 + 2]]) - X) div 2 + X;
            end;
          end
          else
          begin
            for C := 2 downto 0 do
            begin
              Px[0] := BmpPixels[N][W * 3 + C];
              HTagColor[N] := HTagColor[N] + HexString[Px[0] shr 4 + 1] + HexString[Px[0] and 15 + 1];
            end;
          end;
        end;
      end;
      if Method > 0 then
      begin
        case Tag[0] shl 1 or Tag[1] of
          0: PseudoJS[H * BmpInput.Width + H + W] := 0;
          1: PseudoJS[H * BmpInput.Width + H + W] := JTagColor[1] or 1 shl 24;
          2: PseudoJS[H * BmpInput.Width + H + W] := JTagColor[0] shl 12 or 1 shl 25;
          3: PseudoJS[H * BmpInput.Width + H + W] := JTagColor[0] shl 12 or JTagColor[1] or 3 shl 24;
        end;
      end
      else
      begin
        if Tag[0] or Tag[1] = 1 then
        begin
          if (Rx[0] <> Rx[1]) or (Rx[2] <> Rx[3]) then
          begin
            if Closing then ShortBuffer := '</span><span style="' else ShortBuffer := '<span style="';
            for N := 0 to 1 do if Tag[N] = 1 then ShortBuffer := ShortBuffer + SpanStyle[N] + HTagColor[N] + ';';
            ShortBuffer := ShortBuffer + '">';
            Merge(ShortBuffer, HtmBuffer, HtmSeek, Length(ShortBuffer));
            Closing := True;
          end;
          Merge('&#9604;', HtmBuffer, HtmSeek, 7);
        end
        else
        begin
          if Closing then
          begin
            Merge('</span>', HtmBuffer, HtmSeek, 7);
            Closing := False;
          end;
          Merge('&#9604;', HtmBuffer, HtmSeek, 7);
        end;
      end;
    end;
    if Method > 0 then PseudoJS[(H + 1) * BmpInput.Width + H] := 1 shl 26 else Merge('<br>', HtmBuffer, HtmSeek, 4);
  end;

{------------------------------------------------------------------------------}

  if Method > 0 then
  begin
    X := (Method shr 2) and 1;
    Write('<script type="text/javascript">' + #10);
    if X = 0 then
    begin
      SetLength(Palette, PalSeek);
      Write(Palette + ']' + #10 + 'var x = "";' + #10 + 'var y = "";' + #10);
    end else Write('var x = 0;' + #10 + 'var y = 0;' + #10);
    WriteLn(
              'function l()    {document.write("<br>")}'
      + #10 + 'function w()    {document.write("&#9604;")}'
      + #10 + 'function f(x)   {document.write("<span style=\"color:'            + StlPixSng[X] + ';\">&#9604;</span>")}'
      + #10 + 'function b(x)   {document.write("<span style=\"background-color:' + StlPixSng[X] + ';\">&#9604;</span>")}'
      + #10 + 'function d(x,y) {document.write("<span style=\"'                  + StlPixDbl[X] + ';\">&#9604;</span>")}'
      );
    JSCodify;
  end;

{------------------------------------------------------------------------------}

  SetLength(HtmBuffer, HtmSeek);
  WriteLn(HtmBuffer);
  if Method > 0 then WriteLn('</script>') else WriteLn('</span>');
  WriteLn('</div>' + #10 + '</body>' + #10 + '</html>');

{------------------------------------------------------------------------------}

  BmpInput.Free;
  ExitCode := 0;

end.

